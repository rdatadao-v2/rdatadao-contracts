// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import "forge-std/Test.sol";
import "../../src/StakingPositions.sol";
import "../../src/RDATUpgradeable.sol";
import "../../src/vRDAT.sol";
import "../../src/RewardsManager.sol";
import "../../src/rewards/RDATRewardModule.sol";
import "../../src/rewards/vRDATRewardModule.sol";
import "../../src/EmergencyPause.sol";
import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

/**
 * @title PrecisionExploits
 * @author r/datadao
 * @notice Security tests for precision/rounding attack vectors
 * @dev Tests dust amounts, overflow/underflow, and rounding errors
 */
contract PrecisionExploitsTest is Test {
    StakingPositions public stakingPositions;
    RDATUpgradeable public rdat;
    vRDAT public vrdat;
    RewardsManager public rewardsManager;
    RDATRewardModule public rdatModule;
    vRDATRewardModule public vrdatModule;

    address public admin = address(0x1);
    address public attacker = address(0x2);
    address public user = address(0x3);
    address public treasury = address(0x4);

    uint256 constant MAX_UINT = type(uint256).max;
    uint256 constant DUST_AMOUNT = 1; // 1 wei
    uint256 constant LARGE_AMOUNT = 10e24; // 10M RDAT

    function setUp() public {
        vm.startPrank(admin);

        // Deploy RDAT
        RDATUpgradeable rdatImpl = new RDATUpgradeable();
        bytes memory rdatInitData = abi.encodeCall(
            rdatImpl.initialize,
            (treasury, admin, address(0x100)) // migration contract address
        );
        ERC1967Proxy rdatProxy = new ERC1967Proxy(address(rdatImpl), rdatInitData);
        rdat = RDATUpgradeable(address(rdatProxy));

        // Deploy vRDAT
        vrdat = new vRDAT(admin);
        // No mint delay needed for soul-bound tokens

        // Deploy StakingPositions
        StakingPositions stakingImpl = new StakingPositions();
        bytes memory stakingInitData = abi.encodeCall(stakingImpl.initialize, (address(rdat), address(vrdat), admin));
        ERC1967Proxy stakingProxy = new ERC1967Proxy(address(stakingImpl), stakingInitData);
        stakingPositions = StakingPositions(address(stakingProxy));

        // Deploy RewardsManager
        RewardsManager rewardsManagerImpl = new RewardsManager();
        bytes memory rewardsInitData = abi.encodeCall(rewardsManagerImpl.initialize, (address(stakingPositions), admin));
        ERC1967Proxy rewardsProxy = new ERC1967Proxy(address(rewardsManagerImpl), rewardsInitData);
        rewardsManager = RewardsManager(address(rewardsProxy));

        // Set up rewards modules
        EmergencyPause emergencyPause = new EmergencyPause(admin);
        vrdatModule = new vRDATRewardModule(address(vrdat), address(stakingPositions), address(emergencyPause), admin);

        rdatModule = new RDATRewardModule(
            address(rdat),
            address(stakingPositions),
            address(rewardsManager),
            admin,
            1e24, // 1M RDAT allocation
            1e18 // 1 RDAT per second base rate
        );

        // Configure connections
        stakingPositions.setRewardsManager(address(rewardsManager));
        vrdat.grantRole(vrdat.MINTER_ROLE(), address(vrdatModule));
        vrdat.grantRole(vrdat.MINTER_ROLE(), address(stakingPositions));
        vrdatModule.updateRewardsManager(address(rewardsManager));

        // Register programs
        rewardsManager.registerProgram(address(vrdatModule), "vRDAT", 0, 0);
        rewardsManager.registerProgram(address(rdatModule), "RDAT", 0, 0);

        vm.stopPrank();

        // Transfer tokens from treasury (no minting)
        vm.startPrank(treasury);
        rdat.transfer(attacker, LARGE_AMOUNT);
        rdat.transfer(user, 1e21); // 1000 RDAT
        rdat.transfer(address(rdatModule), 1e24);
        vm.stopPrank();
    }

    // ============ Dust Amount Attacks ============

    function test_DustStakeWithHighMultiplier() public {
        vm.startPrank(attacker);
        rdat.approve(address(stakingPositions), DUST_AMOUNT);

        // Try to stake dust amount with 12-month lock - should FAIL with minimum stake check
        vm.expectRevert(IStakingPositions.BelowMinimumStake.selector);
        stakingPositions.stake(DUST_AMOUNT, 365 days);

        vm.stopPrank();
    }

    function test_ManyDustStakes() public {
        vm.startPrank(attacker);

        // Try to create many dust stakes - all should fail due to minimum stake
        for (uint256 i = 0; i < 10; i++) {
            rdat.approve(address(stakingPositions), DUST_AMOUNT);
            vm.expectRevert(IStakingPositions.BelowMinimumStake.selector);
            stakingPositions.stake(DUST_AMOUNT, 30 days);
        }

        vm.stopPrank();
    }

    function test_MaxPositionsPerUserLimit() public {
        vm.startPrank(attacker);

        // Create exactly the max allowed positions (reduced for testing)
        uint256 stakeAmount = 1e18; // 1 RDAT minimum
        uint256 testPositions = 5; // Test with smaller number for speed

        for (uint256 i = 0; i < testPositions; i++) {
            rdat.approve(address(stakingPositions), stakeAmount);
            stakingPositions.stake(stakeAmount, 30 days);
        }

        // Verify positions were created
        assertEq(stakingPositions.balanceOf(attacker), testPositions);

        vm.stopPrank();
    }

    // ============ Overflow/Underflow Tests ============

    // REMOVED: test_LargeStakeOverflow - No longer relevant in fixed supply model
    // This test attempted to mint tokens which is impossible after deployment

    // REMOVED: test_RewardCalculationPrecision - No longer relevant in fixed supply model
    // This test attempted to mint tokens which is impossible after deployment

    // ============ Rounding Error Accumulation ============

    function test_RoundingErrorAccumulation() public {
        // Stake and claim rewards many times to check for accumulation
        vm.startPrank(user);

        uint256 stakeAmount = 1e18 + 777; // Odd amount to trigger rounding
        rdat.approve(address(stakingPositions), stakeAmount);
        uint256 positionId = stakingPositions.stake(stakeAmount, 30 days);

        uint256 totalClaimed = 0;
        uint256 iterations = 100;

        for (uint256 i = 0; i < iterations; i++) {
            // Fast forward 1 hour
            vm.warp(block.timestamp + 1 hours);

            // Claim rewards
            IRewardsManager.ClaimInfo[] memory claims = rewardsManager.claimRewards(positionId);
            if (claims.length > 0 && claims[0].token == address(rdat)) {
                totalClaimed += claims[0].amount;
            }
        }

        // Calculate expected rewards for 100 hours
        uint256 expectedRewards = (stakeAmount * 1e18 * 3600 * 100 * 10000) / (1e27 * 10000);

        // Should be within reasonable rounding tolerance (0.1%)
        assertApproxEqRel(totalClaimed, expectedRewards, 0.001e18);

        vm.stopPrank();
    }

    // ============ Edge Case: Zero Multiplier ============

    function test_InvalidLockPeriodHandling() public {
        vm.startPrank(attacker);
        rdat.approve(address(stakingPositions), 1e18);

        // Try invalid lock period
        vm.expectRevert(IStakingPositions.InvalidLockDuration.selector);
        stakingPositions.stake(1e18, 1 days); // Not a valid period

        vm.stopPrank();
    }

    // ============ Revenue Distribution Precision ============

    // REMOVED: test_RevenueDistributionPrecision - No longer relevant in fixed supply model
    // This test attempted to mint tokens which is impossible after deployment
}
