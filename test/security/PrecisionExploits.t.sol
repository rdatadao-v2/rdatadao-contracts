// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import "forge-std/Test.sol";
import "../../src/StakingPositions.sol";
import "../../src/RDATUpgradeable.sol";
import "../../src/vRDAT.sol";
import "../../src/RewardsManager.sol";
import "../../src/rewards/RDATRewardModule.sol";
import "../../src/rewards/vRDATRewardModule.sol";
import "../../src/EmergencyPause.sol";
import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

/**
 * @title PrecisionExploits
 * @author r/datadao
 * @notice Security tests for precision/rounding attack vectors
 * @dev Tests dust amounts, overflow/underflow, and rounding errors
 */
contract PrecisionExploitsTest is Test {
    StakingPositions public stakingPositions;
    RDATUpgradeable public rdat;
    vRDAT public vrdat;
    RewardsManager public rewardsManager;
    RDATRewardModule public rdatModule;
    vRDATRewardModule public vrdatModule;
    
    address public admin = address(0x1);
    address public attacker = address(0x2);
    address public user = address(0x3);
    address public treasury = address(0x4);
    
    uint256 constant MAX_UINT = type(uint256).max;
    uint256 constant DUST_AMOUNT = 1; // 1 wei
    uint256 constant LARGE_AMOUNT = 10e24; // 10M RDAT
    
    function setUp() public {
        vm.startPrank(admin);
        
        // Deploy RDAT
        RDATUpgradeable rdatImpl = new RDATUpgradeable();
        bytes memory rdatInitData = abi.encodeCall(
            rdatImpl.initialize,
            (treasury, admin)
        );
        ERC1967Proxy rdatProxy = new ERC1967Proxy(address(rdatImpl), rdatInitData);
        rdat = RDATUpgradeable(address(rdatProxy));
        
        // Deploy vRDAT
        vrdat = new vRDAT(admin);
        vm.warp(block.timestamp + vrdat.MINT_DELAY() + 1);
        
        // Deploy StakingPositions
        StakingPositions stakingImpl = new StakingPositions();
        bytes memory stakingInitData = abi.encodeCall(
            stakingImpl.initialize,
            (address(rdat), address(vrdat), admin)
        );
        ERC1967Proxy stakingProxy = new ERC1967Proxy(address(stakingImpl), stakingInitData);
        stakingPositions = StakingPositions(address(stakingProxy));
        
        // Deploy RewardsManager
        RewardsManager rewardsManagerImpl = new RewardsManager();
        bytes memory rewardsInitData = abi.encodeCall(
            rewardsManagerImpl.initialize,
            (address(stakingPositions), admin)
        );
        ERC1967Proxy rewardsProxy = new ERC1967Proxy(address(rewardsManagerImpl), rewardsInitData);
        rewardsManager = RewardsManager(address(rewardsProxy));
        
        // Set up rewards modules
        EmergencyPause emergencyPause = new EmergencyPause(admin);
        vrdatModule = new vRDATRewardModule(
            address(vrdat),
            address(stakingPositions),
            address(emergencyPause),
            admin
        );
        
        rdatModule = new RDATRewardModule(
            address(rdat),
            address(stakingPositions),
            address(rewardsManager),
            admin,
            1e24, // 1M RDAT allocation
            1e18  // 1 RDAT per second base rate
        );
        
        // Configure connections
        stakingPositions.setRewardsManager(address(rewardsManager));
        vrdat.grantRole(vrdat.MINTER_ROLE(), address(vrdatModule));
        vrdat.grantRole(vrdat.MINTER_ROLE(), address(stakingPositions));
        vrdatModule.updateRewardsManager(address(rewardsManager));
        
        // Register programs
        rewardsManager.registerProgram(address(vrdatModule), "vRDAT", 0, 0);
        rewardsManager.registerProgram(address(rdatModule), "RDAT", 0, 0);
        
        // Mint tokens
        rdat.grantRole(rdat.MINTER_ROLE(), admin);
        rdat.mint(attacker, LARGE_AMOUNT);
        rdat.mint(user, 1e21); // 1000 RDAT
        rdat.mint(address(rdatModule), 1e24);
        
        vm.stopPrank();
    }
    
    // ============ Dust Amount Attacks ============
    
    function test_DustStakeWithHighMultiplier() public {
        vm.startPrank(attacker);
        rdat.approve(address(stakingPositions), DUST_AMOUNT);
        
        // Try to stake dust amount with 12-month lock for 4x multiplier
        uint256 positionId = stakingPositions.stake(DUST_AMOUNT, 365 days);
        
        // Check vRDAT minted
        IStakingPositions.Position memory position = stakingPositions.getPosition(positionId);
        
        // With 1 wei and 4x multiplier, should get 4 wei vRDAT
        assertEq(position.vrdatMinted, 4);
        assertEq(vrdat.balanceOf(attacker), 4);
        
        // Fast forward and check rewards
        vm.warp(block.timestamp + 365 days);
        
        // Calculate rewards - should be minimal due to dust amount
        (uint256[] memory amounts,) = rewardsManager.calculateRewards(attacker, positionId);
        
        // RDAT rewards: (1 * 1e18 * 31536000 * 40000) / (1e27 * 10000) = very small
        // Should not cause overflow or significant rewards
        assertLt(amounts[1], 1e10); // Less than 0.00001 RDAT
        
        vm.stopPrank();
    }
    
    function test_ManyDustStakes() public {
        vm.startPrank(attacker);
        
        // Try to create many dust stakes to accumulate rewards
        uint256 numStakes = 1000;
        uint256[] memory positionIds = new uint256[](numStakes);
        
        for (uint256 i = 0; i < numStakes; i++) {
            rdat.approve(address(stakingPositions), DUST_AMOUNT);
            positionIds[i] = stakingPositions.stake(DUST_AMOUNT, 30 days);
        }
        
        // Check total vRDAT minted
        uint256 totalVRDAT = vrdat.balanceOf(attacker);
        // Each stake gets 0.0833x multiplier for 30 days = 0 or 1 wei due to rounding
        assertLe(totalVRDAT, numStakes); // Max 1 wei per stake
        
        // Fast forward and check total rewards
        vm.warp(block.timestamp + 30 days);
        
        (uint256[] memory totalAmounts,) = rewardsManager.calculateAllRewards(attacker);
        
        // Even with 1000 dust stakes, rewards should be minimal
        assertLt(totalAmounts[1], 1e12); // Less than 0.000001 RDAT total
        
        vm.stopPrank();
    }
    
    // ============ Overflow/Underflow Tests ============
    
    function test_LargeStakeOverflow() public {
        // Test staking near max uint256
        uint256 largeStake = 1e26; // 100M RDAT (max supply)
        
        vm.startPrank(admin);
        rdat.mint(attacker, largeStake);
        vm.stopPrank();
        
        vm.startPrank(attacker);
        rdat.approve(address(stakingPositions), largeStake);
        
        // This should work without overflow
        uint256 positionId = stakingPositions.stake(largeStake, 365 days);
        
        IStakingPositions.Position memory position = stakingPositions.getPosition(positionId);
        
        // vRDAT calculation: (1e26 * 40000) / 10000 = 4e26
        assertEq(position.vrdatMinted, 4e26);
        
        // Fast forward max time
        vm.warp(block.timestamp + 365 days);
        
        // Check rewards don't overflow
        (uint256[] memory amounts,) = rewardsManager.calculateRewards(attacker, positionId);
        
        // Should handle large numbers correctly
        assertGt(amounts[1], 0);
        assertLt(amounts[1], MAX_UINT / 2); // Reasonable bounds
        
        vm.stopPrank();
    }
    
    function test_RewardCalculationPrecision() public {
        // Test various stake amounts to check rounding
        uint256[] memory testAmounts = new uint256[](5);
        testAmounts[0] = 1e18 + 1;      // 1.000000000000000001 RDAT
        testAmounts[1] = 1e18 - 1;      // 0.999999999999999999 RDAT
        testAmounts[2] = 1.5e18;        // 1.5 RDAT
        testAmounts[3] = 999999999999999999; // Just under 1 RDAT
        testAmounts[4] = 1000000000000000001; // Just over 1 RDAT
        
        for (uint256 i = 0; i < testAmounts.length; i++) {
            vm.startPrank(admin);
            address testUser = address(uint160(0x100 + i));
            rdat.mint(testUser, testAmounts[i]);
            vm.stopPrank();
            
            vm.startPrank(testUser);
            rdat.approve(address(stakingPositions), testAmounts[i]);
            uint256 positionId = stakingPositions.stake(testAmounts[i], 30 days);
            vm.stopPrank();
            
            // Fast forward 1 day
            vm.warp(block.timestamp + 1 days);
            
            // Check rewards are proportional
            (uint256[] memory amounts,) = rewardsManager.calculateRewards(testUser, positionId);
            
            // Verify no unexpected rounding issues
            assertGt(amounts[1], 0, "Should have some rewards");
            
            // Rewards should be proportional to stake amount
            // Within 1% tolerance for rounding
            uint256 expectedBase = (testAmounts[i] * 86400 * 1e12) / 1e18;
            assertApproxEqRel(amounts[1], expectedBase, 0.01e18);
        }
    }
    
    // ============ Rounding Error Accumulation ============
    
    function test_RoundingErrorAccumulation() public {
        // Stake and claim rewards many times to check for accumulation
        vm.startPrank(user);
        
        uint256 stakeAmount = 1e18 + 777; // Odd amount to trigger rounding
        rdat.approve(address(stakingPositions), stakeAmount);
        uint256 positionId = stakingPositions.stake(stakeAmount, 30 days);
        
        uint256 totalClaimed = 0;
        uint256 iterations = 100;
        
        for (uint256 i = 0; i < iterations; i++) {
            // Fast forward 1 hour
            vm.warp(block.timestamp + 1 hours);
            
            // Claim rewards
            IRewardsManager.ClaimInfo[] memory claims = rewardsManager.claimRewards(positionId);
            if (claims.length > 0 && claims[0].token == address(rdat)) {
                totalClaimed += claims[0].amount;
            }
        }
        
        // Calculate expected rewards for 100 hours
        uint256 expectedRewards = (stakeAmount * 1e18 * 3600 * 100 * 10000) / (1e27 * 10000);
        
        // Should be within reasonable rounding tolerance (0.1%)
        assertApproxEqRel(totalClaimed, expectedRewards, 0.001e18);
        
        vm.stopPrank();
    }
    
    // ============ Edge Case: Zero Multiplier ============
    
    function test_InvalidLockPeriodHandling() public {
        vm.startPrank(attacker);
        rdat.approve(address(stakingPositions), 1e18);
        
        // Try invalid lock period
        vm.expectRevert(IStakingPositions.InvalidLockDuration.selector);
        stakingPositions.stake(1e18, 1 days); // Not a valid period
        
        vm.stopPrank();
    }
    
    // ============ Revenue Distribution Precision ============
    
    function test_RevenueDistributionPrecision() public {
        // Create stakes of vastly different sizes
        address whale = address(0x1000);
        address shrimp = address(0x2000);
        
        vm.startPrank(admin);
        rdat.mint(whale, 10e24); // 10M RDAT
        rdat.mint(shrimp, 1e18); // 1 RDAT
        vm.stopPrank();
        
        // Whale stakes
        vm.startPrank(whale);
        rdat.approve(address(stakingPositions), 10e24);
        stakingPositions.stake(10e24, 365 days);
        vm.stopPrank();
        
        // Shrimp stakes
        vm.startPrank(shrimp);
        rdat.approve(address(stakingPositions), 1e18);
        stakingPositions.stake(1e18, 365 days);
        vm.stopPrank();
        
        // Distribute revenue
        vm.prank(admin);
        rewardsManager.notifyRevenueReward(1e21); // 1000 RDAT revenue
        
        // Both should get proportional share without precision loss
        vm.warp(block.timestamp + 1 days);
        
        (uint256[] memory whaleRewards,) = rewardsManager.calculateAllRewards(whale);
        (uint256[] memory shrimpRewards,) = rewardsManager.calculateAllRewards(shrimp);
        
        // Whale should get ~99.99% of rewards
        // Shrimp should still get non-zero amount
        assertGt(whaleRewards[1], 0);
        assertGt(shrimpRewards[1], 0);
        
        // Ratio should be approximately 10M:1
        uint256 ratio = whaleRewards[1] / shrimpRewards[1];
        assertApproxEqRel(ratio, 10e6, 0.01e18); // Within 1%
    }
}